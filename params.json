{"name":"Spy","tagline":"A simple opinionated mocking framework. All the features of rspec-mocks and more in half the code.","body":"[![Gem Version](https://badge.fury.io/rb/spy.png)](http://badge.fury.io/rb/spy)\r\n[![Build Status](https://travis-ci.org/ryanong/spy.png?branch=master)](https://travis-ci.org/ryanong/spy)\r\n[![Coverage Status](https://coveralls.io/repos/ryanong/spy/badge.png?branch=master)](https://coveralls.io/r/ryanong/spy)\r\n\r\n\r\n[Docs](http://rdoc.info/gems/spy/frames)\r\n\r\nSpy is a lightweight stubbing framework with support for method spies, constant stubs, and object mocks.\r\n\r\nSpy was designed for 1.9.3+.\r\n\r\nSpy features that were completed were tested against the rspec-mocks tests so it covers all cases that rspec-mocks does.\r\n\r\nInspired by the spy api of the jasmine javascript testing framework.\r\n\r\n## Why use this instead of rspec-mocks, mocha, or etc\r\n\r\n* Spy will raise error when you try to stub/spy a method that doesn't exist\r\n  * when you change your method name your unit tests will break\r\n  * no more fantasy tests\r\n* Spy arity matches original method\r\n  * Your tests will raise an error if you use the wrong arity\r\n* Spy visibility matches original method\r\n  * Your tests will raise an error if you try to call the method incorrectly\r\n* Simple call log api\r\n  * easier to read tests\r\n  * use ruby to test ruby instead of a dsl\r\n* no expectations\r\n  * really who thought that was a good idea?\r\n* absolutely no polution of global object space\r\n* no polution of instance variables for stubbed objects\r\n\r\nFail faster, code faster.\r\n\r\n## Why not to use this\r\n\r\n* mocking null objects is not supported(yet)\r\n* no argument matchers for `Spy::Subroutine#has_been_called_with`\r\n* cannot watch all calls to an object to check order in which they are called\r\n* cannot transfer nested constants when stubbing a constant\r\n  * i don't think anybody uses this anyway\r\n  * nobody on github does\r\n* #with is not supported\r\n  * you can usually just check the call logs.\r\n  * if you do need to use this. It is probably a code smell. You either need to abstract your method more or add separate tests.\r\n* you want to use dumb double, Spy has smart mocks, they are better\r\n* you use `mock_model` and `stub_model` (I want to impliment this soon)\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'spy'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install spy\r\n\r\n## Usage\r\n\r\n### Method Stubs\r\n\r\nA method stub overrides a pre-existing method and records all calls to specified method. You can set the spy to return either the original method or your own custom implementation.\r\n\r\nSpy support 2 different ways of spying an existing method on an object.\r\n\r\n```ruby\r\nSpy.on(book, title: \"East of Eden\")\r\nSpy.on(book, :title).and_return(\"East of Eden\")\r\nSpy.on(book, :title).and_return { \"East of Eden\" }\r\n\r\nbook.title  #=> \"East of Eden\"\r\n```\r\n\r\nSpy will raise an error if you try to stub on a method that doesn't exist.\r\nYou can force the creation of a stub on method that didn't exist but it really isn't suggested.\r\n\r\n```ruby\r\nSpy::Subroutine.new(book, :flamethrower).hook(force:true).and_return(\"burnninante\")\r\n```\r\n\r\nYou can also stub instance methods of Classes and Modules. This is equivalent to\r\nrspec-mock's `Module#any_instance`\r\n\r\n```ruby\r\nSpy.on_instance_method(Book, :title).and_return(\"Cannery Row\")\r\n\r\nBook.new(title: \"Siddhartha\").title   #=> \"Cannery Row\"\r\nBook.new(title: \"The Big Cheese\").title   #=> \"Cannery Row\"\r\n```\r\n\r\n### Test Mocks\r\n\r\nA test mock is an object that quacks like a given class but will raise an error\r\nwhen the method is not stubbed. Spy will not let you stub a method that wasn't\r\non the mocked class. You can spy on the classes and call through to the original method.\r\n\r\n```ruby\r\nbook = Spy.mock(Book) # Must be a class\r\nSpy.on(book, first_name: \"Neil\", last_name: \"Gaiman\")\r\nSpy.on(book, :author).and_call_through\r\nbook.author #=> \"Neil Gaiman\"\r\n\r\nbook.responds_to? :title #=> true\r\nbook.title #=> Spy::NeverHookedError: 'title' was never hooked on mock spy.\r\n```\r\n\r\nTo stub methods during instantiation just add arguments.\r\n\r\n```ruby\r\nbook = Spy.mock(Book, :first_name, author: \"Neil Gaiman\")\r\n```\r\n\r\n### Arbitrary Handling\r\n\r\nIf you need to have a custom method based in the method inputs just send a block to `#and_return`\r\n\r\n```ruby\r\nSpy.on(book, :read_page).and_return do |page, &block|\r\n  block.call\r\n  \"awesome \" * page\r\nend\r\n```\r\n\r\nAn error will raise if the arity of the block is larger than the arity of the original method. However this can be overidden with the force argument.\r\n\r\n```ruby\r\nSpy.on(book, :read_page).and_return(force: true) do |a, b, c, d|\r\nend\r\n```\r\n\r\n### Method Spies\r\n\r\nWhen you stub a method it returns a spy. A spy records what calls have been made to a given method.\r\n\r\n```ruby\r\nvalidator = Spy.mock(Validator)\r\nvalidate_spy = Spy.on(validator, :validate)\r\nvalidate_spy.has_been_called? #=> false\r\n\r\nvalidator.validate(\"01234\")   #=> nil\r\nvalidate_spy.has_been_called? #=> true\r\nvalidate_spy.has_been_called_with?(\"01234\") #=> true\r\n```\r\n\r\nYou can also retrieve a method spy on demand\r\n\r\n```ruby\r\nSpy.get(validator, :validate)\r\n```\r\n\r\n### Calling through\r\nIf you just want to make sure if a method is called and not override the output you can just use the `#and_call_through` method\r\n\r\n```ruby\r\nSpy.on(book, :read_page).and_call_through\r\n```\r\n\r\nBy if the original method never existed it will call `#method_missing` on the spied object.\r\n\r\n### Call Logs\r\n\r\nWhen a spy is called on it records a call log. A call log contains the object it was called on, the arguments and block that were sent to method and what it returned.\r\n\r\n```ruby\r\nread_page_spy = Spy.on(book, read_page: \"hello world\")\r\nbook.read_page(5) { \"this is a block\" }\r\nbook.read_page(3)\r\nbook.read_page(7)\r\nread_page_spy.calls.size #=> 3\r\nfirst_call = read_page_spy.calls.first\r\nfirst_call.object #=> book\r\nfirst_call.args   #=> [5]\r\nfirst_call.block  #=> Proc.new { \"this is a block\" }\r\nfirst_call.result #=> \"hello world\"\r\nfirst_call.called_from #=> \"file_name.rb:line_number\"\r\n```\r\n\r\n## Test Framework Integration\r\n\r\n### MiniTest/TestUnit\r\n\r\nin your `test_helper.rb` add this line after you include your framework\r\n\r\n```ruby\r\nrequire 'spy/integration'\r\n```\r\n\r\nIn your test file\r\n\r\n```ruby\r\n  def test_title\r\n    book = Book.new\r\n    title_spy = Spy.on(book, title)\r\n    book.title\r\n    book.title\r\n\r\n    assert_received book, :title\r\n\r\n    assert title_spy.has_been_called?\r\n    assert_equal 2, title_spy.calls.count\r\n  end\r\n```\r\n\r\n### Rspec\r\n\r\nIn `spec_helper.rb`\r\n\r\n```ruby\r\nrequire \"rspec/autorun\"\r\nrequire \"spy/integration\"\r\nRSpec.configure do |c|\r\n  c.mock_with Spy::RspecAdapter\r\nend\r\n```\r\n\r\nIn your test\r\n\r\n```ruby\r\ndescribe Book do\r\n  it \"title can be called\" do\r\n    book = book.new\r\n    page_spy = Spy.on(book, page)\r\n    book.page(1)\r\n    book.page(2)\r\n\r\n    expect(book).to have_received(:page)\r\n    expect(book).to have_received(:page).with(1)\r\n    expect(book).to have_received(:page).with(2)\r\n\r\n    expect(page_spy).to have_been_called\r\n    expect(page_spy.calls.count).to eq(2)\r\n  end\r\nend\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}